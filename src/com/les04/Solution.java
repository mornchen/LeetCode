package com.les04;

/**
 * 字母异位词检测工具类
 * 功能：判断两个字符串是否为字母异位词（包含相同字母但顺序不同）
 * 算法特性：
 *   - 时间复杂度：O(n)（只需遍历两次字符串）
 *   - 空间复杂度：O(1)（固定26长度数组）
 * 实现原理：
 *   利用小写字母ASCII连续特性，通过26位数组统计字符频率差异
 *   同步增减计数实现高效比较，完全匹配时所有计数器归零
 */
public class Solution {

    /**
     * 测试入口
     * 示例演示标准异位词检测流程
     */
    public static void main(String[] args) {
        // 测试用例1：标准异位词（字母相同顺序不同）
        String s = "anagram";  // 原始字符串
        String t = "nagaram";  // 重排后的字符串

        Solution sl = new Solution();
        // 调用核心检测方法并打印结果
        System.out.println(sl.isAnagram(s, t)); // 预期输出：true
    }

    /**
     * 核心方法：字母异位词检测
     * 实现思路分四个阶段：
     *   1. 快速失败检查（长度不同直接返回false）
     *   2. 初始化26字母计数器
     *   3. 同步统计字符频率（s字符+1，t字符-1）
     *   4. 验证计数器完全归零
     *
     * @param s 待检测字符串（仅含小写字母）
     * @param t 待检测字符串（仅含小写字母）
     * @return 是否为字母异位词
     */
    public boolean isAnagram(String s, String t) {
        /* 阶段1：快速失败检查（防御性编程）
         * 设计原理：异位词必须长度相同
         * 时间复杂度：O(1)的快速判断
         * 优化意义：避免不必要的后续计算
         * 代码细节：
         *   - length()方法获取字符串长度
         *   - !=操作符比较长度差异
         */
        if (s.length() != t.length()) {
            return false;  // 长度不同直接判定非异位词
        }

        /* 阶段2：初始化字母计数器
         * 技术细节：
         *   - 创建26长度数组对应a-z（'a'=97, 'z'=122）
         *   - 索引计算：字符ASCII码 - 'a'（如'b'-'a'=1）
         * 空间优化：相比HashMap更节省内存
         * 初始化说明：
         *   - Java数组默认初始化为全0
         *   - 每个位置对应字母的出现次数
         */
        int[] count = new int[26];  // 默认初始化为全0

        /* 阶段3：同步统计字符频率（核心算法）
         * 同步处理技巧：
         *   - 对s字符执行+1操作（记录多出的字符）
         *   - 对t字符执行-1操作（抵消s的字符）
         * 数学原理：
         *   若为异位词，最终所有count应归零（正负抵消）
         * 循环细节：
         *   - 使用charAt()直接访问字符，避免创建char数组
         *   - 同步处理减少循环次数（优于分开两次遍历）
         */
        for (int i = 0; i < s.length(); i++) {
            // 处理s字符：增加对应字母计数
            // 技术细节：
            //   - charAt(i)获取第i个字符
            //   - 'a'-'a'=0, 'b'-'a'=1,...'z'-'a'=25
            //   - ++操作符递增计数
            count[s.charAt(i) - 'a']++;
            // 等价于：count[s.charAt(i) - 97]++

            // 处理t字符：减少对应字母计数
            // 设计考虑：
            //   - 同步操作保证最终count表示频率差
            //   - 若为异位词，正负应完全抵消
            count[t.charAt(i) - 'a']--;
        }

        /* 阶段4：验证计数器归零
         * 遍历检查26个计数器是否全为0
         * 性能说明：
         *   - 固定26次循环（时间复杂度O(1)）
         *   - 任一非零立即返回false（短路优化）
         * 检查逻辑：
         *   - 遍历count数组所有元素
         *   - 使用!=操作符检测非零值
         */
        for (int i = 0; i < 26; i++) {
            if (count[i] != 0) {
                return false;  // 存在未抵消字符
            }
        }

        // 所有计数器归零，确认为异位词
        return true;
    }
}